<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>3D电气室</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" media="screen" href="css/index.css" />
    <!-- <script src="main.js"></script> -->
</head>
<body>
    <div id="view"></div>
    <script type="text/javascript" src="js/jquery.min.js"></script>
    <script type="text/javascript" src="js/three.min.js"></script>
    <script type="text/javascript" src="js/Detector.js"></script>
    <script type="text/javascript" src="js/OrbitControls.js"></script>
    <script type="text/javascript" src="js/stats.min.js"></script>
    <script type="text/javascript">
        (function() {
            // 严格模式
            'use strict'
            // 常量空间
            const axisJson = {

            }

            // 变量空间
            let finder = {

            }

            window.onload = () => {
                init()
            }

            let init = () => {
                let surge,  // Json 数据
                    props = {
                        describArr: [],  // 机箱名称
                        arr1: [],  // 烟感
                        arr2: [],  // 温感
                        arr3: [],  // 控制器
                        machinePositionArr: [],  // 机箱位置
                        airPositionArr: [],  // 空调位置
                        smokePositionArr: [],   // 烟感位置
                        temperaturePositionArr: [],  // 温感位置
                        controllerPositionArr: [],  // 控制器位置
                        fontPositionArr: []  // 名称位置
                    },
                    attach = {

                    }
                $.post('./json/axis.json',function(result,state){
                    surge = JSON.parse(result)
                    if (result) {
                        // 机柜空调坐标、名称以及名称坐标
                        $.each(surge.List[0].describ, function(index, val) {
                            if (val.CABINET_TYPE == "0") {
                                props.machinePositionArr.push(val.CABINET_COORDINATE.split(","))
                            } else if (val.CABINET_TYPE == "1") {
                                props.airPositionArr.push(val.CABINET_COORDINATE.split(","))
                            }
                            props.fontPositionArr.push(val.DESCRIB_COORDINATE.split(","))
                            props.describArr.push(val.CABINET_NAME)
                        })
                        // 烟感、温感、控制器坐标
                        $.each(surge.List[0].equipInfo, function(index, val) {
                            // 温感
                            if (val.eqType == "02") {
                                props.temperaturePositionArr.push(val.EQ_COORDINATE.split(","))
                            // 烟感
                            } else if (val.eqType == "03") {
                                props.smokePositionArr.push(val.EQ_COORDINATE.split(","))
                            // 控制器
                            } else if (val.eqType == "25" || "29") {
                                props.controllerPositionArr.push(val.EQ_COORDINATE.split(","))
                            }
                        })
                        workshop(props,attach)
                    } else {
                        console.log('axisJson 数据异常')
                    }
                })
            }

            let workshop = (props,attach) => {
                debugger
                let three = {
                        scene: null,
                        camera: null,
                        renderer: null,
                        light: null,
                        controls: null,
                        width: null,
                        height: null,
                        states: null,
                        background: 0x1e1e24
                    },
                    geometry = null,
                    material = null,
                    texture = null,
                    model = null,
                    loader = null,
                    modelClone = null
                three.width = document.getElementById('view').offsetWidth
                three.height = document.getElementById('view').offsetHeight

                //兼容性判断
                // (!Detector.webgl) && Detector.addGetWebGLMessage()

                // 建造场景
                let initScene = () => {
                    three.scene = new THREE.Scene()
                    three.scene.position.z = 120;
                }

                // 透视投影相机
                let initCamera = () => {
                    three.camera =  new THREE.PerspectiveCamera(35,three.width / three.height,0.1,3000)  // 可视角度，显示口的宽高比，近裁剪面，远裁剪面
                    three.camera.position.set(0, 1000, 1100)
                    three.camera.lookAt(new THREE.Vector3(0, 2500, 0)) // 设置摄像机观察的方向
                }

                // 渲染器
                let initRender = () => {
                    three.renderer = new THREE.WebGLRenderer({antialias: true}) // 新建一个渲染器, 渲染器用来输出最终结果
                    three.renderer.setSize(three.width, three.height) // 设置渲染的尺寸, 在这里是浏览器尺寸
                    three.renderer.setClearColor(three.background) // 设置背景的颜色
                    three.renderer.shadowMap.enabled = true // 设置是否开启投影, 开启的话, 光照会产生投影
                    three.renderer.shadowMap.type = THREE.PCFSoftShadowMap // 设置投影类型, 这边是柔和投影
                    document.getElementById('view').appendChild(three.renderer.domElement) // 创建 canvas
                }

                // 光源
                let initLight = () => {
                    // 平行的一束光，模拟从很远处照射的太阳光
                    // DirectionalLight( color, intensity )

                    three.light = new THREE.DirectionalLight(0xffffff,1)  // color — 光的颜色值，十六进制，默认值为0xffffff,intensity — 光的强度，默认值为1
                    three.light.position.set(500, 1000, 500)
                    three.light.target.position.set(0, 0, 0)
                    three.light.castShadow = false
                    const d = 300
                    // 正交投影相机
                    // var camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far)
                    three.light.shadow.camera = new THREE.OrthographicCamera(-d,d,d,-d,500,1600 )
                    three.light.shadow.bias = 0.0001
                    three.light.shadow.mapSize.width = three.light.shadow.mapSize.height = 1024
                    three.scene.add(three.light)
                    // 环境光( AmbientLight )：笼罩在整个空间无处不在的光
                    three.scene.add(new THREE.AmbientLight(0xffffff, 0.3))
                }

                let initModel = () => {
                    let fontModel = (fontPositionArr,describArr) => {
                        loader = new THREE.FontLoader()
                        loader.load("font/MicrosoftYaHei_Regular.json",function(res) {
                            for (let i = 0,l = fontPositionArr.length; i <l ; i++) {
                                geometry = new THREE.TextBufferGeometry(describArr[i], {
                                    font: res,
                                    size: 11,
                                    height: 1
                                })
                                geometry.computeBoundingBox() // 运行以后设置font的boundingBox属性对象，如果不运行无法获得。
                                material = new THREE.MeshLambertMaterial({})
                                model = new THREE.Mesh(geometry, material)
                                //设置位置
                                modelClone = model.clone()
                                modelClone.position.set(
                                    fontPositionArr[i][0],
                                    fontPositionArr[i][1],
                                    fontPositionArr[i][2]
                                )
                                three.scene.add(modelClone)
                            }
                        })
                    }

                    let base = () => {
                        // 创建底座 长/宽/高
                        geometry = new THREE.BoxBufferGeometry(1000, 10, 600)
                        // 设置材质
                        texture = new THREE.TextureLoader().load( "img/floor.jpg")
                        texture.wrapS = THREE.RepeatWrapping
                        texture.wrapT = THREE.RepeatWrapping
                        texture.repeat.set(8, 8)
                        material = new THREE.MeshLambertMaterial({ map: texture,color: 0xc6e2ff})
                        model = new THREE.Mesh(geometry, material)
                        model.rotation.z = -Math.PI
                        model.position.y = -1
                        three.scene.add(model)
                    }

                    // 文字模型
                    fontModel(props.fontPositionArr, props.describArr)
                    // 底座
                    base()


                }

                //初始化性能插件
                let initStats = () => {
                    three.stats = new Stats();
                    document.body.appendChild(three.stats.dom);
                }

                // 鼠标控制
                let initControls = () => {
                    three.controls = new THREE.OrbitControls(three.camera, three.renderer.domElement)
                    //设置控制器的中心点
                    //controls.target.set( 0, 5, 0 )
                    // 如果使用animate方法时，将此函数删除
                    //controls.addEventListener( 'change', render )
                    // 使动画循环使用时阻尼或自转 意思是否有惯性
                    three.controls.enableDamping = true
                    //动态阻尼系数 就是鼠标拖拽旋转灵敏度
                    three.controls.dampingFactor = 0.25
                    // 旋转速度
                    three.controls.rotateSpeed = 0.35
                    //是否可以缩放
                    three.controls.enableZoom = true
                    //是否自动旋转
                    three.controls.autoRotate = false
                    three.controls.autoRotateSpeed = 0.5
                    //设置相机距离原点的最远距离
                    three.controls.minDistance = 1
                    //设置相机距离原点的最远距离
                    three.controls.maxDistance = 2000
                    //是否开启右键拖拽
                    three.controls.enablePan = true
                }

                let loop = () => {
                    //更新性能插件
                    three.stats.update();

                    three.renderer.render(three.scene, three.camera) // 渲染器开始渲染, scene 和 camera 是必须参数, 因为场景里有动画, 所以放在 loop 里循环
                    requestAnimationFrame(loop)
                }

                let onWindowResize = () => {
                    window.addEventListener('resize', function() {
                        three.camera.aspect = three.width / three.height
                        three.camera.updateProjectionMatrix()
                        three.renderer.setSize(three.width, three.height)
                    })
                }

                let draw = () => {
                    initScene()
                    initCamera()
                    initRender()
                    initLight()
                    initModel()
                    initControls()
                    initStats()
                    loop()
                    onWindowResize()
                }

                draw()
            }
        }());
    </script>
</body>
</html>